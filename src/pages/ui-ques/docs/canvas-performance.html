<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Canvas Performance Optimization - Interview Notes</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      line-height: 1.7;
      color: #2d3436;
      background: linear-gradient(135deg, #f5f7fa 0%, #e4e8ec 100%);
      min-height: 100vh;
      padding: 40px 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.1);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: white;
      padding: 40px;
      text-align: center;
    }

    .header h1 {
      font-size: 2.2rem;
      margin-bottom: 10px;
      font-weight: 700;
    }

    .header p {
      color: #a0aec0;
      font-size: 1.1rem;
    }

    .content {
      padding: 40px;
    }

    h2 {
      color: #1a1a2e;
      font-size: 1.5rem;
      margin: 35px 0 20px 0;
      padding-bottom: 10px;
      border-bottom: 3px solid #e94560;
      display: inline-block;
    }

    h2:first-of-type {
      margin-top: 0;
    }

    h3 {
      color: #0f3460;
      font-size: 1.2rem;
      margin: 25px 0 12px 0;
    }

    h4 {
      color: #e94560;
      font-size: 1.05rem;
      margin: 20px 0 10px 0;
    }

    p {
      margin-bottom: 12px;
      color: #4a5568;
    }

    ul, ol {
      margin: 12px 0 12px 25px;
    }

    li {
      margin-bottom: 8px;
      color: #4a5568;
    }

    .highlight {
      background: linear-gradient(120deg, #fff3cd 0%, #fff3cd 100%);
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
    }

    .code-block {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 16px 20px;
      border-radius: 8px;
      font-family: 'Fira Code', 'Consolas', monospace;
      font-size: 0.9rem;
      margin: 15px 0;
      overflow-x: auto;
      border-left: 4px solid #e94560;
    }

    .code-block .comment {
      color: #6a9955;
    }

    .code-block .keyword {
      color: #569cd6;
    }

    .code-block .string {
      color: #ce9178;
    }

    .code-block .function {
      color: #dcdcaa;
    }

    .code-inline {
      background: #f1f5f9;
      color: #e94560;
      padding: 2px 8px;
      border-radius: 4px;
      font-family: 'Fira Code', 'Consolas', monospace;
      font-size: 0.9rem;
    }

    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      font-size: 0.95rem;
      box-shadow: 0 2px 15px rgba(0,0,0,0.08);
      border-radius: 8px;
      overflow: hidden;
    }

    .comparison-table th {
      background: #1a1a2e;
      color: white;
      padding: 14px 16px;
      text-align: left;
      font-weight: 600;
    }

    .comparison-table td {
      padding: 12px 16px;
      border-bottom: 1px solid #e2e8f0;
    }

    .comparison-table tr:nth-child(even) {
      background: #f8fafc;
    }

    .comparison-table tr:hover {
      background: #edf2f7;
    }

    .tip-box {
      background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
      border-left: 4px solid #27ae60;
      padding: 16px 20px;
      margin: 20px 0;
      border-radius: 0 8px 8px 0;
    }

    .tip-box strong {
      color: #27ae60;
    }

    .warning-box {
      background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
      border-left: 4px solid #f39c12;
      padding: 16px 20px;
      margin: 20px 0;
      border-radius: 0 8px 8px 0;
    }

    .warning-box strong {
      color: #e67e22;
    }

    .interview-q {
      background: #f8fafc;
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      border: 1px solid #e2e8f0;
    }

    .interview-q .question {
      font-weight: 700;
      color: #1a1a2e;
      font-size: 1.05rem;
      margin-bottom: 12px;
      display: flex;
      align-items: flex-start;
      gap: 10px;
    }

    .interview-q .question::before {
      content: "Q";
      background: #e94560;
      color: white;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      flex-shrink: 0;
    }

    .interview-q .answer {
      color: #4a5568;
      padding-left: 38px;
    }

    .cheat-sheet {
      background: linear-gradient(135deg, #ffeef1 0%, #ffe4e8 100%);
      border-radius: 12px;
      padding: 25px;
      margin: 25px 0;
    }

    .cheat-sheet h3 {
      color: #e94560;
      margin-top: 0;
    }

    .cheat-sheet table {
      width: 100%;
      border-collapse: collapse;
    }

    .cheat-sheet th {
      background: #e94560;
      color: white;
      padding: 12px;
      text-align: left;
    }

    .cheat-sheet td {
      padding: 10px 12px;
      border-bottom: 1px solid #f5c6cb;
      background: white;
    }

    .cheat-sheet code {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 0.85rem;
    }

    .pipeline-comparison {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
    }

    .pipeline-box {
      background: #f8fafc;
      border-radius: 12px;
      padding: 20px;
      border: 2px solid #e2e8f0;
    }

    .pipeline-box.dom {
      border-color: #e74c3c;
    }

    .pipeline-box.canvas {
      border-color: #27ae60;
    }

    .pipeline-box h4 {
      margin-top: 0;
      margin-bottom: 15px;
    }

    .pipeline-box.dom h4 {
      color: #e74c3c;
    }

    .pipeline-box.canvas h4 {
      color: #27ae60;
    }

    .pipeline-step {
      background: white;
      padding: 8px 12px;
      margin: 6px 0;
      border-radius: 6px;
      font-size: 0.9rem;
      border-left: 3px solid #cbd5e0;
    }

    .decision-list {
      background: #f0f9ff;
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
    }

    .decision-list li {
      margin-bottom: 12px;
    }

    .decision-list strong {
      color: #0f3460;
    }

    .footer {
      background: #1a1a2e;
      color: white;
      text-align: center;
      padding: 25px;
      margin-top: 40px;
    }

    .footer p {
      color: #a0aec0;
      margin: 0;
    }

    .footer .key-takeaway {
      color: #e94560;
      font-weight: 600;
      font-size: 1.1rem;
    }

    @media (max-width: 768px) {
      .pipeline-comparison {
        grid-template-columns: 1fr;
      }

      .header h1 {
        font-size: 1.8rem;
      }

      .content {
        padding: 25px;
      }
    }

    @media print {
      body {
        background: white;
        padding: 0;
      }

      .container {
        box-shadow: none;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üé® Canvas Performance Optimization</h1>
      <p>Frontend Interview Preparation Notes</p>
    </div>

    <div class="content">
      <!-- Section 1 -->
      <h2>1. What is HTML5 Canvas?</h2>
      <p>
        The HTML5 <code class="code-inline">&lt;canvas&gt;</code> element provides a drawable region where you can render 2D graphics using JavaScript. Unlike DOM-based rendering, Canvas uses <span class="highlight">immediate mode rendering</span> ‚Äî drawing directly to pixels without maintaining a scene graph.
      </p>

      <h3>Key Characteristics</h3>
      <ul>
        <li><strong>Pixel-based (raster):</strong> Renders as bitmap, resolution-dependent</li>
        <li><strong>Immediate mode:</strong> No DOM nodes, draws directly to pixel buffer</li>
        <li><strong>Stateless:</strong> Must redraw entire scene each frame</li>
        <li><strong>GPU-accelerated:</strong> Modern browsers use hardware acceleration</li>
      </ul>

      <!-- Section 2 -->
      <h2>2. Why is Canvas Better for Performance?</h2>

      <div class="pipeline-comparison">
        <div class="pipeline-box dom">
          <h4>‚ùå DOM Rendering Pipeline</h4>
          <div class="pipeline-step">1. Parse HTML ‚Üí Build DOM tree</div>
          <div class="pipeline-step">2. Parse CSS ‚Üí Build CSSOM</div>
          <div class="pipeline-step">3. Combine ‚Üí Render tree</div>
          <div class="pipeline-step">4. Layout (reflow) ‚Üí Calculate positions</div>
          <div class="pipeline-step">5. Paint ‚Üí Draw pixels</div>
          <div class="pipeline-step">6. Composite ‚Üí Layer composition</div>
          <p style="margin-top: 12px; color: #e74c3c; font-weight: 600;">
            Problem: Each DOM change triggers reflow/repaint for potentially thousands of elements.
          </p>
        </div>

        <div class="pipeline-box canvas">
          <h4>‚úÖ Canvas Rendering Pipeline</h4>
          <div class="pipeline-step">1. JavaScript draws to pixel buffer</div>
          <div class="pipeline-step">2. Single composite to screen</div>
          <div class="pipeline-step">3. Done! ‚úì</div>
          <p style="margin-top: 12px; color: #27ae60; font-weight: 600;">
            Benefit: Bypasses the entire DOM rendering pipeline. O(1) composite vs O(n) reflow.
          </p>
        </div>
      </div>

      <!-- Section 3 -->
      <h2>3. Optimization Techniques</h2>

      <h4>3.1 Use requestAnimationFrame (Not setInterval)</h4>
      <p>setInterval/setTimeout are not synchronized with the browser's refresh rate and continue running in background tabs.</p>
      <div class="code-block">
        <span class="comment">// ‚ùå Bad</span><br>
        <span class="function">setInterval</span>(() => <span class="function">draw</span>(), <span class="string">16</span>);<br><br>
        <span class="comment">// ‚úÖ Good</span><br>
        <span class="keyword">function</span> <span class="function">animate</span>() {<br>
        &nbsp;&nbsp;<span class="function">draw</span>();<br>
        &nbsp;&nbsp;<span class="function">requestAnimationFrame</span>(animate);<br>
        }<br>
        <span class="function">requestAnimationFrame</span>(animate);
      </div>
      <ul>
        <li>Syncs with display refresh rate (typically 60fps)</li>
        <li>Automatically pauses when tab is inactive</li>
        <li>Browser can optimize rendering batch</li>
      </ul>

      <h4>3.2 Offscreen Canvas (Pre-rendering)</h4>
      <p>For complex shapes drawn repeatedly, render once to an offscreen canvas and copy it each frame.</p>
      <div class="code-block">
        <span class="keyword">const</span> offscreen = document.<span class="function">createElement</span>(<span class="string">'canvas'</span>);<br>
        offscreen.width = <span class="string">100</span>;<br>
        offscreen.height = <span class="string">100</span>;<br>
        <span class="keyword">const</span> offCtx = offscreen.<span class="function">getContext</span>(<span class="string">'2d'</span>);<br><br>
        <span class="comment">// Draw complex shape once</span><br>
        <span class="function">drawComplexCharacter</span>(offCtx);<br><br>
        <span class="comment">// In animation loop - just copy!</span><br>
        ctx.<span class="function">drawImage</span>(offscreen, x, y);
      </div>

      <h4>3.3 Layer Multiple Canvases</h4>
      <p>Separate static and dynamic content into different canvas layers.</p>
      <div class="code-block">
        &lt;<span class="keyword">div</span> id=<span class="string">"game"</span>&gt;<br>
        &nbsp;&nbsp;&lt;<span class="keyword">canvas</span> id=<span class="string">"background"</span>&gt;&lt;/<span class="keyword">canvas</span>&gt; <span class="comment">&lt;!-- Rarely updates --&gt;</span><br>
        &nbsp;&nbsp;&lt;<span class="keyword">canvas</span> id=<span class="string">"gameplay"</span>&gt;&lt;/<span class="keyword">canvas</span>&gt;&nbsp;&nbsp; <span class="comment">&lt;!-- Updates every frame --&gt;</span><br>
        &nbsp;&nbsp;&lt;<span class="keyword">canvas</span> id=<span class="string">"ui"</span>&gt;&lt;/<span class="keyword">canvas</span>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="comment">&lt;!-- Updates on user action --&gt;</span><br>
        &lt;/<span class="keyword">div</span>&gt;
      </div>

      <h4>3.4 Disable Alpha Channel</h4>
      <div class="code-block">
        <span class="keyword">const</span> ctx = canvas.<span class="function">getContext</span>(<span class="string">'2d'</span>, { <span class="keyword">alpha</span>: <span class="string">false</span> });
      </div>
      <p>Browser skips alpha compositing calculations. Use when canvas doesn't need transparency.</p>

      <h4>3.5 Avoid Sub-pixel Rendering</h4>
      <div class="code-block">
        <span class="comment">// ‚ùå Bad - causes anti-aliasing overhead</span><br>
        ctx.<span class="function">drawImage</span>(img, <span class="string">10.5</span>, <span class="string">20.3</span>);<br><br>
        <span class="comment">// ‚úÖ Good - use integers</span><br>
        ctx.<span class="function">drawImage</span>(img, Math.<span class="function">round</span>(x), Math.<span class="function">round</span>(y));
      </div>

      <h4>3.6 Batch Similar Operations</h4>
      <p>State changes (fillStyle, strokeStyle, font) are expensive. Group similar operations.</p>
      <div class="code-block">
        <span class="comment">// ‚úÖ Set state once, then draw all items of that type</span><br>
        ctx.fillStyle = <span class="string">'red'</span>;<br>
        items.<span class="function">forEach</span>(i => ctx.<span class="function">fillRect</span>(i.x, i.y, <span class="string">10</span>, <span class="string">10</span>));
      </div>

      <h4>3.7 Dirty Rectangle Rendering</h4>
      <p>Only clear and redraw the portion of canvas that changed.</p>
      <div class="code-block">
        ctx.<span class="function">clearRect</span>(dirtyX, dirtyY, dirtyWidth, dirtyHeight);<br>
        <span class="comment">// Redraw only affected area</span>
      </div>

      <h4>3.8 Use CSS for Static Elements</h4>
      <p>Let CSS handle static backgrounds and overlays. Canvas only for dynamic content.</p>

      <!-- Section 4 -->
      <h2>4. Canvas vs SVG vs DOM</h2>

      <table class="comparison-table">
        <thead>
          <tr>
            <th>Aspect</th>
            <th>Canvas</th>
            <th>SVG</th>
            <th>DOM</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Rendering</strong></td>
            <td>Immediate (pixels)</td>
            <td>Retained (DOM)</td>
            <td>Retained (DOM)</td>
          </tr>
          <tr>
            <td><strong>Performance</strong></td>
            <td>Best for 1000+ objects</td>
            <td>Good for &lt;1000</td>
            <td>Limited elements</td>
          </tr>
          <tr>
            <td><strong>Scaling</strong></td>
            <td>Pixelated on zoom</td>
            <td>Resolution independent</td>
            <td>CSS-based scaling</td>
          </tr>
          <tr>
            <td><strong>Events</strong></td>
            <td>Manual hit detection</td>
            <td>Built-in per element</td>
            <td>Built-in per element</td>
          </tr>
          <tr>
            <td><strong>Accessibility</strong></td>
            <td>Poor (needs ARIA)</td>
            <td>Good (DOM-based)</td>
            <td>Excellent</td>
          </tr>
          <tr>
            <td><strong>Use Cases</strong></td>
            <td>Games, real-time viz</td>
            <td>Charts, icons, maps</td>
            <td>UI components</td>
          </tr>
        </tbody>
      </table>

      <div class="decision-list">
        <h3>Decision Framework</h3>
        <ul>
          <li><strong>Use Canvas when:</strong> Many objects (1000+), real-time updates, games, pixel manipulation, complex animations</li>
          <li><strong>Use SVG when:</strong> Fewer interactive objects, need scalability, charts/graphs, icons, accessibility matters</li>
          <li><strong>Use DOM when:</strong> Standard UI, text-heavy content, SEO important, accessibility critical</li>
        </ul>
      </div>

      <!-- Section 5 -->
      <h2>5. Canvas Trade-offs</h2>

      <div class="tip-box">
        <strong>‚úÖ Advantages:</strong>
        <ul style="margin-top: 10px;">
          <li>Extremely fast for large numbers of objects</li>
          <li>Pixel-level control</li>
          <li>No DOM overhead</li>
          <li>Great for real-time graphics</li>
        </ul>
      </div>

      <div class="warning-box">
        <strong>‚ö†Ô∏è Disadvantages:</strong>
        <ul style="margin-top: 10px;">
          <li><strong>Poor accessibility:</strong> Screen readers can't interpret canvas content</li>
          <li><strong>Manual everything:</strong> Hit detection, event handling, state management</li>
          <li><strong>Resolution issues:</strong> Blurry on high-DPI displays without handling</li>
          <li><strong>No SEO:</strong> Search engines can't index canvas content</li>
          <li><strong>Memory intensive:</strong> Large canvases consume significant memory</li>
        </ul>
      </div>

      <!-- Section 6 -->
      <h2>6. Common Interview Questions</h2>

      <div class="interview-q">
        <div class="question">What is Canvas and why is it better for performance?</div>
        <div class="answer">Canvas renders pixels directly, bypassing the DOM. No style recalculation, no layout/reflow, no DOM tree traversal. It's immediate mode vs retained mode rendering ‚Äî the browser simply composites the canvas buffer to the screen.</div>
      </div>

      <div class="interview-q">
        <div class="question">How would you optimize a slow canvas animation?</div>
        <div class="answer">Use requestAnimationFrame, pre-render to offscreen canvas, layer canvases, batch draw calls, disable alpha if not needed, use dirty rectangle rendering, avoid sub-pixel positions, and minimize state changes.</div>
      </div>

      <div class="interview-q">
        <div class="question">Canvas vs SVG ‚Äî when would you use each?</div>
        <div class="answer">Canvas for many objects (1000+), real-time updates, games, pixel manipulation. SVG for fewer interactive elements, scalability requirements, accessibility, charts/graphs. SVG retains DOM structure; Canvas doesn't.</div>
      </div>

      <div class="interview-q">
        <div class="question">What are the drawbacks of using Canvas?</div>
        <div class="answer">Poor accessibility (no DOM for screen readers), manual hit detection required, no built-in events per shape, resolution-dependent graphics, no SEO benefit, more code to maintain, memory-intensive for large sizes.</div>
      </div>

      <div class="interview-q">
        <div class="question">Explain requestAnimationFrame vs setInterval for animations.</div>
        <div class="answer">rAF syncs with display refresh (usually 60fps), pauses in background tabs, allows browser optimization. setInterval runs regardless of refresh rate, can cause jank, wastes resources when tab is in background.</div>
      </div>

      <div class="interview-q">
        <div class="question">What is offscreen canvas?</div>
        <div class="answer">A canvas not attached to DOM used for pre-rendering. Draw complex shapes once to offscreen canvas, then copy to visible canvas using drawImage(). Reduces redundant calculations per frame.</div>
      </div>

      <!-- Section 7 -->
      <div class="cheat-sheet">
        <h3>üìã Quick Reference Cheat Sheet</h3>
        <table>
          <thead>
            <tr>
              <th>Technique</th>
              <th>Code / Explanation</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>requestAnimationFrame</td>
              <td><code>requestAnimationFrame(animate)</code></td>
            </tr>
            <tr>
              <td>Disable alpha</td>
              <td><code>getContext('2d', { alpha: false })</code></td>
            </tr>
            <tr>
              <td>Offscreen canvas</td>
              <td><code>document.createElement('canvas')</code></td>
            </tr>
            <tr>
              <td>Integer positions</td>
              <td><code>Math.round(x), Math.round(y)</code></td>
            </tr>
            <tr>
              <td>Batch operations</td>
              <td>Set fillStyle once, draw all same-colored items</td>
            </tr>
            <tr>
              <td>Layer canvases</td>
              <td>Static bg + dynamic gameplay + UI overlays</td>
            </tr>
            <tr>
              <td>Dirty rectangles</td>
              <td>Only clearRect/redraw changed areas</td>
            </tr>
          </tbody>
        </table>
      </div>

    </div>

    <div class="footer">
      <p class="key-takeaway">"Compute as little as possible, Draw as little as possible"</p>
      <p style="margin-top: 10px;">Canvas Performance = Bypassing DOM + Smart Rendering Strategies</p>
    </div>
  </div>
</body>
</html>